# E18

## API : add

minimum la m√©thode `POST`

```php
/**
 * @Route("/api/genres", name="app_api_genre_add", methods={"POST"})
 */
public function add(){}
```

Quand on est en mode "API", si on permet la cr√©ation avec la route `POST`, on doit s'attendre √† recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on re√ßoit et üí• on a un objet PHP.

On injecte la requ√®te HTTP dans notre fonction pour en r√©cup√©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;
public function createItem(Request $request)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme pr√©vu on `deserialize`, c'est √† dire que l'on transforme le JSON en Objet en pr√©cisant l'entit√© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;
public function createItem(Request $request, SerializerInterface $serializer)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

üéâ trop facile, on donnes √ßa √† Doctrine pour qu'il le mettes en BDD et c'est bon üí™

```php
use Doctrine\ORM\EntityManagerInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entit√©
    $doctrine->persist($movie);
    $doctrine->flush();
```

üòÖ `SQLSTATE[xxxx] xxxx cannot be null`

Comment √ßa MySQL n'est pas content ? üëø

Ben oui, il manque des donn√©es, on va demander √† Symfony de nous valider tout √ßa üí™ et surtout de nous dire ce qui coince.
Comme √ßa on pr√©vient notre utilisateur en front et on lui d√©crit les probl√®mes pour qu'il s'adapte et qu'il nous envoie les bonnes donn√©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine, ValidatorInterface $validator)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entit√©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);
    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // @todo Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entit√©
    $doctrine->persist($movie);
    $doctrine->flush();

    // on renvoit un code 201 et l'objet cr√©e
    return $this->json($movie, Response::HTTP_CREATED);
```

On a encore la possibilit√© de recevoir du json mal form√©.
Il faut odnc que l'on s'assure que la d√©s√©rialisation se passe bien, pour cela on l'entoure d'un try-Catch

```php
try {
    $genreFromJson = $serializer->deserialize(
        // 1. le json
        $contentJson,
        // 2. le type, c√†d la classe Entit√©
        Genre::class,
        // 3. le format de donn√©es
        'json'
        // 4. le contexte, pour l'instant rien √† y mettre
    );
} catch (\Throwable $e){
    // la d√©s√©rialisation ne s'est pas bien pass√©e
}
```

### m√©thode de modification

On fait la m√™me chose, les m√™mes traitements que la m√©thode de cr√©ation

On r√©cup√®re l'entit√© √† modifier depuis un param√®tre de route (`{id}`)
On r√©cup√®re les valeurs √† modifier depuis le json de la requete

Il faut faire la mise √† jour de chaque prorpri√©t√©.

Cela peut √™tre long et probl√©matique, car si on nous ne donne pas de nouvelle valeur pour une propri√©t√©, elle sera donc nulle dans le json.

On utilise donc le 4eme param√®tre de la d√©serialisation : `[AbstractNormalizer::OBJECT_TO_POPULATE => $entityFromRoute]`

On pr√©cise l'objet √† mettre √† jour en lui donnant l'entit√© que l'on a r√©cup√©rer depuis notre route.

le d√©serilizer va lui m√™me faire les mise √† jour des valeurs, et donc uniquement des valeurs qui sont fournies.

[doc](https://symfony.com/doc/current/components/serializer.html#deserializing-in-an-existing-object)

